# Глава 5.1. Повторения (цикли)

В настоящата глава ще се запознаем с конструкциите за **повторение на група команди**, известни в програмирането с понятието "**цикли**". Ще напишем няколко цикъла с използване на оператора **`for`** в най-простата му форма. Накрая ще решим няколко практически задачи, изискващи повторение на поредица от действия, като използваме цикли.

## Видео

<div class="video-player">
  Гледайте видео-урок по тази глава тук: <a target="_blank"
  href="https://www.youtube.com/watch?v=7D7fECmq_VQ">
  https://www.youtube.com/watch?v=7D7fECmq_VQ</a>.
</div>

## Повторения на блокове код (for цикъл)

В програмирането често се налага **да се изпълни блок с команди няколко пъти**. За целта се използват т.нар. **цикли**. Нека разгледаме един пример за **`for` цикъл**, който преминава последователно през числата от 1 до 10 и ги отпечатва в конзолата:

![](/assets/chapter-5-images/00.For-loop-01.png)

Цикълът започва с **оператора `for`** и преминава през всички стойности за дадена променлива в определен интервал, например всички числа от 1 до 10 включително, и за всяка стойност изпълнява поредица от команди.

В декларацията на цикъла може да се зададе **начална стойност** и **крайна стойност**. **Тялото на цикъла** обикновено се огражда с къдрави скоби **`{ }`** и представлява блок с една или няколко команди. На фигурата по-долу е показана структурата на един **`for` цикъл**:

![](/assets/chapter-5-images/00.For-loop-02.png)

В примера по-горе създаваме локалната променливата **`i`** с начална стойност 1 (**`int i = 1`**) и увеличаваме стойноста на променливата с 1 (**`i++`**) всеки път, когато кодът между къдравите скоби се изпълни. Цикълът се повтаря, докато условието **`i <= 10`** е изпълнено (**`true`**). Всяко от тези повторения се нарича "**итерация**".

### Пример: числа от 1 до 100

Да се напише програма, която **отпечатва числата от 1 до 100** едно след друго, по едно на ред.

#### Насоки и подсказки

Можем да решим задачата с **`for` цикъл** , с който преминаваме с променливата **`i`** през числата от 1 до 100 и ги печатаме в тялото на цикъла:

![](/assets/chapter-5-images/01.Numbers-1-to-100-01.png)

**Стартираме** програмата с [**Ctrl+F5**] и я **тестваме**:

![](/assets/chapter-5-images/01.Numbers-1-to-100-02.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#0](https://judge.softuni.bg/Contests/Practice/Index/1364#0).

Трябва да получите **100 точки** (напълно коректно решение).


## Code Snippet за for цикъл във Visual Studio

Когато програмираме, често се налага да пишем цикли. Затова в повечето среди за разработка (IDE) има **шаблони за код** (**code snippets**) за писане на цикли. Един такъв шаблон е **шаблонът за `for` цикъл във Visual Studio**. Напишете **`for`** в редактора за C++ код във Visual Studio и **натиснете два пъти** [**Tab**]. Visual Studio ще разгъне за вас шаблон и ще напише цялостен **`for` цикъл**:

![](/assets/chapter-5-images/00.For-loop-code-snippet-01.png)

**Опитайте сами**, за да усвоите умението да ползвате шаблона за код за **`for` цикъл** във Visual Studio.

### Пример: числа до 1000, завършващи на 7

Да се напише програма, която намира всички числа в интервала **1 до 1000 включително**, които завършват на 7. 

#### Насоки и подсказки

Задачата можем да решим като комбинираме **`for` цикъл**, който минава през **всички** числа от 1 до 1000 и проверява дали **завършват на 7**. Има и други решения, разбира се, но нека решим задачата със **цикъл + проверка**:

![](/assets/chapter-5-images/02.Numbers-ending-in-7-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#1](https://judge.softuni.bg/Contests/Practice/Index/1364#1).


### Пример: всички латински букви

Да се напише програма, която отпечатва буквите от латинската азбука: **a, b, c, …, z**.
    
#### Насоки и подсказки

Символите в C++ биват запазени в паметта като числа. За конвертирането им от число в символ и обратно се използва така наречената **ASCII таблица**. За пример - `а` (малко а) се запазва в паметта на компютъра като числото 97, а `z` (малко z) e 122. Това значи, че можем да създадем цикъл, който използва данни `char` и да променяме символа като увеличаваме числото.

![](/assets/chapter-5-images/03.Latin-letters-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#2](https://judge.softuni.bg/Contests/Practice/Index/1364#2).


### Пример: събиране на числа

Да се напише програма, която **въвежда `n` цели числа и ги събира**.

* На първия ред на входа се въвежда броят числа **`n`**.
* На следващите **`n`** реда се въвежда по едно число.
* Числата се събират и накрая се отпечатва резултатът.

#### Примерен вход и изход

| Вход | Изход |
| --- | --- |
| 2<br>10<br>20 | 30 |
| 3<br>-10<br>-20<br>-30 | -60 |
| 4<br>45<br>-20<br>7<br>11<br> | 43 |
| 1<br>999 | 999 | 
| 0 | 0 |

#### Насоки и подсказки

Можем да решим задачата за събиране на числа по следния начин:
 - Четем входното число **`n`**.
 - Започваме първоначално със сбор **`sum = 0`**.
 - Създаваме цикъл от 0 до **`n`**. На всяка стъпка от цикъла четем число **`num`** и го добавяме към сбора **`sum`**.
 - Накрая отпечатваме полученият сбор **`sum`**.
 
Ето и сорс кода на решението:

![](/assets/chapter-5-images/04.Sum-numbers-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#3](https://judge.softuni.bg/Contests/Practice/Index/1364#3).


### Пример: най-голямо число

Да се напише програма, която **въвежда `n` цели числа и намира най-голямото** измежду тях.

* Въвеждат се броят числа **`n`**.
* На следващите **`n`** реда се въвежда по едно число.
* Най-голямото число се отпечатва на екрана

#### Примерен вход и изход

| Вход | Изход |
| --- | --- |
| 2<br>100<br>99 | 100 | 
| 3<br>-10<br>20<br>-30 | 20 |
| 4<br>45<br>-20<br>7<br>99<br> | 99 | 
| 1<br>999 | 999 |
| 2<br>-1<br>-2 | -1 |

#### Насоки и подсказки

Можем да решим задачата за най-голямо число по следния начин:
 - Въвеждат се броят числа **`n`**.
 - Проверяваме дали броя числа е по-голям от 0, защото ще вземем първото число отделно. Това се прави, защото трябва да инитциализираме променливата `max` за да можем да проверяваме дали следващите числа са по-големи от текущото най-голямо.
 - Създаваме цикъл започващ от 1 (за да прескочим първото число, което взехме отделно) до **`n`**.
 - На всяка стъпка взимаме число и проверяваме дали новото число е по-голямо от последното открито най-голямото и ако е - запазваме стойноста му в промеливата.
 - Накрая отпечатваме променливата в която пазим най-голямото число.

![](/assets/chapter-5-images/05.Max-number-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#4](https://judge.softuni.bg/Contests/Practice/Index/1364#4).


### Пример: най-малко число

Да се напише програма, която въвежда **n цели числа** (**n** > 0) и намира **най-малкото** измежду тях. Първо се въвежда броя числа **n**, след тях още **n** числа по едно на ред. 

#### Примерен вход и изход

| Вход | Изход | 
| --- | --- |
| 2<br>100<br>99 | 99 |
| 3<br>-10<br>20<br>-30 | -30 |
| 4<br>45<br>-20<br>7<br>99<br> | -20 |

#### Насоки и подсказки

Задачата е абсолютно аналогична с предходната, само че с различен знак.

![](/assets/chapter-5-images/06.Min-number-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#5](https://judge.softuni.bg/Contests/Practice/Index/1364#5).


### Пример: ляв и дясен сбор

Да се напише програма, която въвежда **2 \* n цели числа** и проверява дали **сбора на първите n числа** (ляв сбор) е равна на **сбора на вторите n числа** (десен сбор). При равенство се печата **"Yes" + сбора**, иначе се печата **"No" + разликата**. Разликата се изчислява като положително число (по абсолютна стойност). Форматът на изхода трябва да е като в примерите по-долу.

#### Примерен вход и изход

| Вход | Изход | Вход | Изход |
| --- | --- | --- | --- | 
| 2<br>10<br>90<br>60<br>40 | Yes, sum = 100 | 2<br>90<br>9<br>50<br>50 | No, diff = 1 |

#### Насоки и подсказки

Първо въвеждаме числото **n**, след това първите **n** числа (**лявата** половина) и ги събираме. Продължаваме с въвеждането на още **n** числа (**дясната** половина) и намираме и техния сбор. Изчисляваме **разликата** между намерените сборове по абсолютна стойност: **`abs(leftSum - rightSum)`**. Ако разликата е **0**, отпечатваме **"Yes" + сбора**, в противен случай - отпечатваме **"No" + разликата**.

![](assets/chapter-5-images/07.Left-and-right-sum-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#6](https://judge.softuni.bg/Contests/Practice/Index/1364#6).


### Пример: четен / нечетен сбор

Да се напише програма, която въвежда **n цели числа** и проверява дали **сбора на числата на четни позиции** е равен на **сбора на числата на нечетни позиции**. При равенство печата **"Yes" + сбора**, иначе печата **"No" + разликата**. Разликата се изчислява по абсолютна стойност. Форматът на изхода трябва да е като в примерите по-долу.

#### Примерен вход и изход

| Вход | Изход |
| --- | --- |
| 4<br>10<br>50<br>60<br>20 | Yes<br>Sum = 70 |
| 4<br>3<br>5<br>1<br>-2 | No<br>Diff = 1 |
| 3<br>5<br>8<br>1 | No<br>Diff = 2 |

#### Насоки и подсказки

Въвеждаме числата едно по едно и изчисляваме двата **сбора** (на числата на **четни** позиции и на числата на **нечетни** позиции). Както в предходната задача, изчисляваме абсолютната стойност на разликата и отпечатваме резултата (**"Yes" + сбора** при разлика 0 или **"No" + разликата** в противен случай).

![](/assets/chapter-5-images/08.Odd-even-sum-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#7](https://judge.softuni.bg/Contests/Practice/Index/1364#7).


### Пример: събиране на гласните букви

Да се напише програма, която въвежда **текст** (стринг), изчислява и отпечатва **сбора от стойностите на гласните букви** според таблицата по-долу:

| a | e | i | o | u | 
| :---: | :---: | :---: | :---: | :---: |
| 1 | 2 | 3 | 4 | 5 |

#### Примерен вход и изход

| Вход | Изход | Вход | Изход | 
| --- | --- | --- | --- |
| hello | 6<br>(e+o = 2+4 = 6) | bamboo | 9<br>(a+o+o = 1+4+4 = 9) |
| hi | 3<br>(i = 3) | beer | 4<br>(e+e = 2+2 = 4) |

#### Насоки и подсказки

Прочитаме входния текст **`text`**, инитциализираме променлива за сбора и създаваме цикъл от **0** до **`strlen(text)`** (дължината на текста). Проверяваме всяка буква **`text[i]`** дали е гласна и добавяме съответното число към сбора.

![](/assets/chapter-5-images/09.Vowels-sum-01.png)

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#8](https://judge.softuni.bg/Contests/Practice/Index/1364#8).


## Какво научихме от тази глава?

Можем да повтаряме части от кода с **`for` цикъл**:

![](/assets/chapter-5-images/00.For-loop-01.png)

Можем да четем поредица от **`n`** числа от конзолата:

![](/assets/chapter-5-images/00.For-loop-03.png)

## Упражнения: повторения (цикли)

След като се запознахме с циклите, идва време **да затвърдим знанията си на практика**, а както знаете, това става с много писане на код. Да решим няколко задачи за упражнение.

### Празно Visual Studio решение (Blank Solution)

Създаваме празно решение **(Blank Solution)** във Visual Studio, за да организираме по-добре задачите за упражнение. Целта на този **blank solution** e да съдържа **по един проект за всяка задача** от упражненията.
  
![](/assets/chapter-5-images/00.Blank-visual-studio-01.png)

Задаваме **да се стартира по подразбиране текущият проект** (не първият в решението). Кликваме с десен бутон на мишката върху **Solution 'Loops'** -> [**Set StartUp Projects…**] -> [**Current selection**].

### Задача: елемент, равен на сбора на останалите

Да се напише програма, която въвежда **n цели числа** и проверява дали сред тях съществува число, което е равно на сбора на всички останали. Ако има такъв елемент, се отпечатва **"Yes" + неговата стойност**, в противен случай - **"No" + разликата между най-големия елемент и сбора на останалите** (по абсолютна стойност). 

#### Примерен вход и изход

| Вход | Изход | Коментар |
| --- | --- | :---: |
| 7<br>3<br>4<br>1<br>1<br>2<br>12<br>1 | Yes<br>Sum = 12 | 3 + 4 + 1 + 2 + 1 + 1 = 12 |
| 4<br>6<br>1<br>2<br>3 | Yes<br>Sum = 6 | 1 + 2 + 3 = 6 |
| 3<br>1<br>1<br>10 | No<br>Diff = 8 | &#124;10 - (1 + 1)&#124; = 8 |
| 3<br>5<br>5<br>1 | No<br>Diff = 1 | &#124;5 - (5 + 1)&#124; = 1 |
| 3<br>1<br>1<br>1 | No<br>Diff = 1 | - |

#### Насоки и подсказки

Трябва да изчислим **сбора** на всички елементи, да намерим **най-големия** от тях и да проверим търсеното условие.

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#9](https://judge.softuni.bg/Contests/Practice/Index/1364#9).


### Задача: четни / нечетни позиции

Напишете програма, която чете **n числа** и пресмята **сбора**, **минимума** и **максимума** на числата на **четни** и **нечетни** позиции (броим от 1). Когато няма минимален / максимален елемент, отпечатайте **"No"**. 

#### Примерен вход и изход

| Вход | Изход | Вход | Изход |
| --- | --- | --- | --- |
| 6<br>2<br>3<br>5<br>4<br>2<br>1 | OddSum=9,<br>OddMin=2,<br>OddMax=5,<br>EvenSum=8,<br>EvenMin=1,<br>EvenMax=4 | 2<br>1.5<br>-2.5 | OddSum=1.5,<br>OddMin=1.5,<br>OddMax=1.5,<br>EvenSum=-2.5,<br>EvenMin=-2.5,<br>EvenMax=-2.5 |
| 1<br>1 | OddSum=1,<br>OddMin=1,<br>OddMax=1,<br>EvenSum=0,<br>EvenMin=No,<br>EvenMax=No | 0 | OddSum=0,<br>OddMin=No,<br>OddMax=No,<br>EvenSum=0,<br>EvenMin=No,<br>EvenMax=No |
| 5<br>3<br>-2<br>8<br>11<br>-3 | OddSum=8,<br>OddMin=-3,<br>OddMax=8,<br>EvenSum=9,<br>EvenMin=-2,<br>EvenMax=11 | 4<br>1.5<br>1.75<br>1.5<br>1.75 | OddSum=3,<br>OddMin=1.5,<br>OddMax=1.5,<br>EvenSum=3.5,<br>EvenMin=1.75,<br>EvenMax=1.75 |
| 1<br>-5 | OddSum=-5,<br>OddMin=-5,<br>OddMax=-5,<br>EvenSum=0,<br>EvenMin=No,<br>EvenMax=No | 3<br>-1<br>-2<br>-3 | OddSum=-4,<br>OddMin=-3,<br>OddMax=-1,<br>EvenSum=-2,<br>EvenMin=-2,<br>EvenMax=-2 |

#### Насоки и подсказки

Задачата обединява няколко предходни задачи: намиране на **минимум**, **максимум** и **сбор**, както и обработка на елементите от **четни и нечетни позиции**. Припомнете си ги.

В тази задача е по-добре да се работи с **дробни числа** (не цели). Сборът, минимумът и максимумът също са дробни числа. Трябва да използваме **неутрална начална стойност** при намиране на минимум / максимум, например **1000000000.0** и **-1000000000.0**. Ако получим накрая неутралната стойност, печатаме **“No”**.

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#10](https://judge.softuni.bg/Contests/Practice/Index/1364#10).


### Задача: еднакви двойки

Дадени са **2 \* n числа**. Първото и второто формират **двойка**, третото и четвъртото също и т.н. Всяка двойка има **стойност** – сбора от съставящите я числа. Напишете програма, която проверява **дали всички двойки имат еднаква стойност**.

В случай, че е еднаква отпечатайте **"Yes, value=…" + стойността**, в противен случай отпечатайте **максималната разлика** между две последователни двойки в следния формат - **"No, maxdiff=…" + максималната разлика**. 

Входът се състои от число **n**, следвано от **2*n цели числа**, всички по едно на ред.

#### Примерен вход и изход

| Вход | Изход | Коментар |
| --- | --- | :---: | 
| 3<br>1<br>2<br>0<br>3<br>4<br>-1| Yes, value=3 | стойности = {3, 3, 3}<br>еднакви стойности | 
| 2<br>1<br>2<br>2<br>2 | No, maxdiff=1 | стойности = {3, 4}<br>разлики = {1}<br>макс. разлика = 1 |
| 4<br>1<br>1<br>3<br>1<br>2<br>2<br>0<br>0 | No, maxdiff=4 | стойности = {2, 4, 4, 0}<br>разлики = {2, 0, 4}<br>макс. разлика = 4 |
| 1<br>5<br>5 | Yes, value=10 | стойности = {10}<br>една стойност<br>еднакви стойности |
| 2<br>-1<br>0<br>0<br>-1 | Yes, value=-1 | стойности = {-1, -1}<br>еднакви стойности | 
| 2<br>-1<br>2<br>0<br>-1 | No, maxdiff=2 | стойности = {1, -1}<br>разлики = {2}<br>макс. разлика = 2 |

#### Насоки и подсказки

Прочитаме входните числа **по двойки**. За всяка двойка пресмятаме **сбора** ѝ. Докато четем входните двойки, за всяка двойка, без първата, трябва да пресметнем **разликата с предходната**. За целта е необходимо да пазим в отделна променлива сбора на предходната двойка. Накрая намираме **най-голямата разлика** между две двойки. Ако е **0**, печатаме **“Yes”** + стойността, в противен случай - **“No”** + разликата.

#### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/1364#11](https://judge.softuni.bg/Contests/Practice/Index/1364#11).

Ако имате проблеми с примерния проект по-горе, **гледайте видеото** в началото на тази глава. Там приложението е направено на живо стъпка по стъпка с много обяснения. Или питайте във **форума на СофтУни**: https://softuni.bg/forum.
