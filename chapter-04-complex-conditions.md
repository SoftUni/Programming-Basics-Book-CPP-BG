# Глава 4.1. По-сложни проверки

В **настоящата** глава ще се занимаем с правенето на по-сложни проверки в
**C++**.
Първо ще разгледме условни конструкции, които съдържат в тялото си **други
условни конструкции**, това са **вложени условни конструкции**.
След това ще рагледаме **по-сложни логически условия**, чрез които можем да
правим **няколко** проверки в **една** конструкция **`if`**.

## Видео
<div class="video-player">
  Гледайте видео-урок по тази глава тук: <a target="_blank"
  href="https://www.youtu.be/XK8W2DP-oDM">
  https://www.youtu.be/XK8W2DP-oDM</a>.
</div>

## Вложени проверки
**Вложени** проверки наричаме **`if`** или **`if-else`** конструкции, които се
съдържат една в друга.
Терминът произлиза от това, че едната условна конструкция е **вложена** (съдържа
се) в другата.
Тези конструкции се използват често при по-сложни програми.
Общият им вид е следният:

```cpp
if (условие_1) {
    if (условие_2) {
        // тяло
    } else {
        // тяло;
    }
}
```

В C++ са разрешени вложени констукции на няколко нива, т.е. **`if`** в **`if`**
в **`if`** и т.н.
Влагането на **повече от три** условни конструкции една в друга обаче се счита
за **лоша практика**, защото води до трудно четим код.
Можем да избегнем този проблем, като структурираме алгоритъма си по по-хитър
начин или като използваме по-сложни логически условия, описани по-надолу в тази
глава.

### Пример: обръщение според възраст и пол

Според въведени **възраст** (число) и **пол** (**m** / **f**) да се отпечата
обръщение:

* “**Mr.**” – мъж (пол “**m**”) на 16 или повече години.
* “**Master**” – момче (пол “**m**”) под 16 години.
* “**Ms.**” – жена (пол “**f**”) на 16 или повече години.
* “**Miss**” – момиче (пол “**f**”) под 16 години.

#### Примерен вход и изход
|Вход   |Изход|Вход   |Изход|
|-------|-----|-------|-----|
|12<br>f|Miss |17<br>m|Mr.  |

|Вход   |Изход|Вход     |Изход |
|-------|-----|---------|------|
|25<br>f|Ms.  |13.5<br>m|Master|

#### Решение
**Изходът** на решението на задачата **зависи от няколко неща**.
Ще използваме две **вжолени** **`if-else`** конструкци, в които **първо** ще
проверяваме въведения **пол** и **след това** въведената **възраст**.
Проверките са **вложени**, защото искаме от **резултата** на първата да се
определя коя от **другите** проверки да се изпълни;

![](/assets/old-images/chapter-4-images/01.Personal-titles-01.jpg)

```cpp
int age;
string gender;
cin >> age >> gender;
if (gender == "m") {
    if (age < 16)
        cout << "Master" << endl;
    else
        cout << "Mr." << endl;
} else if (gender == "f") {
   if (age < 16)
        cout << "Miss" << endl;
    else
        cout << "Ms." << endl;
}
```

<!--
![](/assets/old-images/chapter-4-images/01.Personal-titles-02.png)

-->

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#0>.

### Пример: квартално магазинче
Предприемчив българин отваря по едно **квартално магазинче** в **няколко града**
с различни **цени** за следните **продукти**:

|продукт|Sofia|Plovdiv|Varna|
|:-----:|:---:|:-----:|:---:|
|coffee |0.50 |0.40   |0.45 |
|water  |0.80 |0.70   |0.70 |
|beer   |1.20 |1.15   |1.10 |
|sweets |1.45 |1.30   |1.35 |
|peanuts|1.60 |1.50   |1.55 |

По дадени **град** (стринг), **продукт** (стринг) и **количество** (десетично
число) на покупка, да се пресметне цената ѝ.

#### Примерен вход и изход
|Вход                |Изход|Вход                   |Изход|
|--------------------|-----|-----------------------|-----|
|coffee<br>Varna<br>2|0.9  |peanuts<br>Plovdiv<br>1|1.5  |

|Вход|Изход|Вход|Изход|
|-------|-------|-------|-------|
|beer<br>Sofia<br>6|7.2|water<br>Plovdiv<br>3|2.1|

#### Решение
```cpp
string product, town;
double quantity;

cin >> product >> town >> quantity;

if (town == "Sofia") {
    if (product == "coffee") {
        cout << 0.50 * quantity << endl;
    }
    //TODO: finish this ...
} else if (town == "Varna") {
    //TODO: finish this ...
}
//TODO: finish this ...
```

<!--
**Прехвърляме** всички букви в **долен регистър** с функцията **`.ToLower()`**, за да сравняваме продукти и градове **без значение** от малки/главни букви.

![](/assets/old-images/chapter-4-images/02.Small-shop-01.png)
-->

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#1>.

## По-сложни проверки
По-сложните логически проверки се състоят от няколко прости условия, обединени
чрез **логичеси оператори**.
Това са логическо "**и**" (**`&&`**), логическо "**или**" (**`||`**),
логическо **отрицание** (**`!`**) и **скоби** (**`()`**).

### Булев тип
Както видяхме в предната глава, резултатите от простите проверки са **`true`**
(**истина**) или **`false`** (**лъжа**).
Освен да ползваме резултата от дадена проверка директно в условна конструкция
(**``if``**), в C++ можем да запазим резултата в променлива, която да ползваме
по-късно.
Тези променливи са от тип **`bool`** и затова се наричат **булеви**:

```cpp
bool condition = (5 > 3) //true
cout << boolalpha << condition << endl; //отпечатва "true"
```

## Логическо "и"
Чрез логическото "**и**" (оператор **`&&`**) проверяваме, дали две условия са
**изпълнени едновременно**.
В долната таблица на истинност е показана стойността на **`a && b`**, за всички
възможни стойности на **`a`** и **`b`**:

|a    |b    |a && b|
|:---:|:---:|:----:|
|true |true |true  |
|true |false|false |
|false|true |false |
|false|false|false |

### Операторът &&
Операторът **`&&`** се прилага две булеви стойности и на свой ред **`&&`** също
връща булева стойност.
Когато **и двата аргумента** имат стойност **`true`**, стойността на израза също
е **`true`**, а в противен случай тя е **`false`**.
Аргументи могат да бъдат както **променливи** от булев тип, така и **резултатите
от други проверки**.

Долният пример показва как можем да използваме операторът **`&&`**, за да
проверим, дали въведено число е по-голямо или равно на **`100`** **и** по-малко
или равно на **`200`**, т.е. дали е **между `100` и `200`**:

```cpp
int a;
cin >> a;
if ((a >= 100) && (a <= 200)) {
    cout << "The number is between 100 and 200" << endl;
}
```
### Повече от двe условия
Чрез оператора && можем дали **две условия** са изпълнени едновременно.
Как да подходим обаче, ако искаме да направим същото за **повече от две
условия**?
Нека първо разгледаме как се решава този проблем при операция, с която сме
по-добре запознати, например събиране:

Подобно на **`&&`**, операторът **`+`** събира две числа.
Ако искаме да съберем **няколко числа**, използваме няколко пъти оператора + по
следния начин:
```cpp
int sum = 1 + 2 + 3 + 4;
```
Изразът се изчислява **от ляво надясно**, като последователно всяко от числата
се събира със сбора на предходните.
Започва се с **`1 + 2 = 3`**, после **`3 + 3 = 6`** и накрая **`6 + 4 = 10`**.

**Аналогично** проверяваме чрез оператор **`&&`**, дали **няколко условия** са
изпълнени **едновременно**:
```cpp
bool a = true;
bool b = true;
bool c = false;
bool d = true;
bool result = a && b && c && d;
```
Изразът отново се изчислява **от ляво надясно**, като последователно се прилага
операцията **логическо "и"** върху текущата булева стойност, и резултата за
предходните.
Започва се с **`a && b = true && true = true`**, после
**`true && c = true && false = false`** и накрая
**`false && d = false && true = false`**.

Всъщност, тъй като след втората операция "и" (**`&&`**) се е получила стойност
**`false`**, **няма как** стойността на целия израз е **`true`**, независимо от
стойностите на останалите булеви условия.
Затова, като се прилага оператор **`&&`** в C++, ако стойността на първия
аргумент е **`false`**, **вторият не се изчислява**, защото е ясно, че
стойността на целия израз ще е **`false`**.

### Логическо "и" и вложени проверки
В предните задачи се налагаше да правим **няколко проверки наведнъж**.
Тогава най-добрият подход беше чрез вложени проверки, защото искахме да се
изпълни някакъв код, както когато беше изпълнено условието (тялото на **`if`**),
така и когато не беше (тялото на **`else`**).
Когато обаче се интересуваме **само от единия случай** (няма **`else`**), е
по-добре да се използва една конструкция **`if`**, в която да са обединени
**няколко прости проверки** чрез оператор **`&&`**.

Ползването на вложени проверки в такива ситуации води до код, който изглежда
**неподреден** и е **труден** за четене и поддръжка.
В сравнение с долния код, този от предната секция е **по-лесно разбираем**,
макар двата кода да правят едно и също:
```cpp
bool result = false;
if (a) {
    if (b) {
        if (c) {
            if (d) {
                result = true;
            }
        }
    }
}
```

### Пример: точка в правоъгълник
Проверка дали **точка {x, y}** се намира **вътре в правоъгълника {x1, y1} –
{x2, y2}**.
Входните данни се четат от конзолата и се състоят от 6 реда: десетичните числа
**x1**, **y1**, **x2**, **y2**, **x** и **y** (като се гарантира, че **x1 < x2**
и **y1 < y2**).

#### Примерен вход и изход
|Вход                         |Изход |Визуализация                                                             |
|-----------------------------|------|:-----------------------------------------------------------------------:|
|2<br>-3<br>12<br>3<br>8<br>-1|Inside|![shop](/assets/old-images/chapter-4-images/03.Point-in-rectangle-01.png)|

#### Решение

Една точка е вътрешна за даден многоъгълник, ако **едновременно** са изпълнени
следните четири условия:

* Точката е вдясно от лявата страна на правоъгълника.
* Точката е вляво от дясната страна на правоъгълника.
* Точката е под горната страна на правоъгълника.
* Точката е над долната страна на правоъгълника.

![](/assets/old-images/chapter-4-images/03.Point-in-rectangle-03.PNG)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#2>.

## Логическо "или"
Чрез логическо **"или"** (оператор **`||`**) проверямаве, дали е
**изпълнено поне едно** от две логически условия.
В долната таблица на истинност е показана стойността на **`a || b`**, за всички
възможни стойности на **`a`** и **`b`**:

|a    |b    |a &#124;&#124; b|
|:---:|:---:|:--------------:|
|true |true |true            |
|true |false|true            |
|false|true |true            |
|false|false|false           |

Забележете, че `a || b` има стойност true дори когато и двете условия са
изпълнени.
Това не съответства изцяло на употребата на думата **"или"** в
ежедневието, но не е и в противоречие с горната дефиниция, тъй като тя изисква
**поне едно** условие да е изпълнено, а не **точно едно**.


### Операторът ||
Подобно на оператора **`&&`**, операторът **`||`** приема като аргументи две
булеви стойности и на свой ред също връща булева стойност
(**`true`** или **`false`**).
Ако искаме да проверим дали **поне едно от няколко** условия е изпълнено, трябва
да приложим някокло пъти оператора **`||`**:

```csharp
bool a = false;
bool b = false;
bool c = true;
bool d = true;
bool result = a || b || c || d;
// true (като c и d не се проверяват)
```

Както при логическото **"и"**, изразът се изчислява **от ляво надясно**, като
този път последователно се прилага операцията **логическо "или"** върху текущата
булева стойност, и резултата за предходните.
Започва се с **`a || b = false || false = false`**, после
**`false || c = false || true = true`** и накрая
**`true || d = true || true = true`**.

Тъй като след втората операция **"или"** (**`||`**) се е получила стойност
**`true`**, **няма как** стойността на целия израз е **`false`**, независимо от
стойностите на останалите булеви условия.
Затова, като се прилага оператор **`||`** в C++, ако стойността на първия
аргумент е **`true`**, **вторият не се изчислява**, защото е ясно, че
стойността на целия израз ще е **`true`**.


### Пример: плод или зеленчук
Нека проверим дали даден **продукт** е **плод** или **зеленчук**.
Плодовете "**fruit**" са **banana**, **apple**, **kiwi**, **cherry**, **lemon**
и **grapes**.
Зеленчуците "**vegetable**" са **tomato**, **cucumber**, **pepper** и
**carrot**.
Всички останали са "**unknown**".

#### Примерен вход и изход
|Вход                    |Изход                        |
|------------------------|-----------------------------|
|banana<br>tomato<br>java|fruit<br>vegetable<br>unknown|

#### Решение
Трябва да използваме няколко условни проверки с логическо "**или**" (**`||`**):

![](/assets/old-images/chapter-4-images/04.Fruit-or-vegetable-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#3>.

## Логическо отрицание
Чрез **логическо отрицание** (оператор **`!`**) проверяваме, дали **не е
изпълнено** дадено условие.

|a    |!a   |
|:---:|:---:|
|true |false|
|false|true |

Операторът **`!`** приема като аргумент **само една** булева стойност и
и връща **противоположната** ѝ булева стойност.

### Пример: невалидно число
Дадено **число е валидно**, ако е в диапазона [**100 … 200**] или е **0**.
Да се направи проверка за **невалидно** число.

#### Примерен вход и изход
|Вход|Изход       |
|----|------------|
|75  |invalid     |
|150 |(няма изход)|
|220 |invalid     |

#### Решение
![](/assets/old-images/chapter-4-images/05.Invalid-number-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#4>.

## Скоби `()`
Подобно на аритметичните изрази, използващи събиране (**`+`**) и умножение
(**`*`**), булевите изрази, съдържащи операциите логическо **"и"** (**`&&`**)
и логическо **"или"** (**`||`**), **не се изпълняват** от ляво надясно.
Операторът **`&&`** е с **по-голям приоритет** и се изпълнява преди **`||`**
точно както умножението се изпълнява преди събирането.

Ако искаме да уточним в какъв ред искаме да се изчислят операциите, трябва да
ползваме скоби **`()`**, както при аритметичните изрази.
При булевите е **препоръчително да се използват скоби** дори когато те не са
необходими, защото така кодът е **по-ясен и разбираем**.

```cpp
bool result1 = a || b && c;
bool result2 = a || (b && c);
bool result3 = (a || b) && c;
```
В горния код има три булеви израза, различаващи се единствено по **скобите**.
Първият и вторият израз са **еквиваленти**, тъй като **`&&`** е с **по-голям
приоритет** от **`||`**, но вторият е **по-лесен за четене**, защото ползва
скоби.
В третия израз редът на извършване на операциите е **променен** и първо се
изпълнява **`a || b`**, вместо **`b && c`**.

## По-сложни логически условия
Сега ще разгледаме по-сложни задачи, които изискзват поредица от проверки или
дълги булеви изрази.

### Пример: точка върху страна на правоъгълник
Да се напише програма, която проверява дали **точка *{x, y}** се намира **върху
някоя от страните на правоъгълник {x1, y1} - {x2, y2}**.
Входните данни се четат от конзолата и се състоят от 6 реда: десетичните числа
**x1**, **y1**, **x2**, **y2**, **x** и **y**
(като се гарантира, че **x1 < x2** и **y1 < y2**).
Да се отпечата "**Border**" (точката лежи на някоя от страните) или
"**Inside / Outside**" (в противен случай).

![](/assets/old-images/chapter-4-images/06.Point-on-rectangle-border-01.png)
#### Примерен вход и изход
|Вход                          |Изход |Вход                         |Изход           |
|------------------------------|------|-----------------------------|----------------|
|2<br>-3<br>12<br>3<br>12<br>-1|Border|2<br>-3<br>12<br>3<br>8<br>-1|Inside / Outside|

#### Решение
Точка лежи върху някоя от страните на правоъгълник, ако:
* **x** съвпада с **x1** и същевременно **y** е между **y1** и **y2** (лява
  страна).
* **x** съвпада с **x2** и същевременно **y** е между **y1** и **y2** (дясна
  страна).
* **y** съвпада с **y1** и същевременно **x** е между **x1** и **x2** (горна
  страна).
* **y** съвпада с **y2** и същевременно **x** е между **x1** и **x2** (долна
  страна).

Това може да се реализира в код директно:
<!--
TODO: picture
-->
```cpp
if (((x == x1) && (y >= y1) && (y <= y2)) ||
    ((x == x2) && (y >= y1) && (y <= y2)) ||
    ((y == y1) && (x >= x1) && (x <= x2)) ||
    ((y == y2) && (x >= x1) && (x <= x2))
) {
    cout << "Border" << endl;
}
```

Макар и верен, горният код съдържа едно дълго и сложно условие, което е **трудно
за разбиране**.
Можем да го опростим, като разделим голямото условие на няколко **по-прости**:
<!--
TODO: picture
-->
```cpp
bool onLeftSide = ((x == x1) && (y >= y1) && (y <= y2));
bool onRightSide = ((x == x2) && (y >= y1) && (y <= y2));
bool onTopSide = ((y == y1) && (x >= x1) && (x <= x2));
bool onBottomSide = ((y == y2) && (x >= x1) && (x <= x2));
if (onLeftSide || onRightSide || onTopSide || onBottomSide) {
    cout << "Border" << endl;
}
```
Макар и по-дълго, второто решение с допълнителните булеви променливи е
**по-лесно за четене**.
Не е важно кодът да е кратък, важно е да е **разбираем**.
Затова е добре, вместо да пишете едно дълго условия, да го разбиете на **някокло
по-кратки**, чиито резултати да помните в променливи с **описателни имена**.

Остава да допишете кода така, че да отпечатва “**Inside / Outside**”, ако
точката не лежи върху някоя от страните на правоъгълника.

#### Тестване в Judge системата
След като допишете решението, може да го тествате тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#5>.

### Пример: магазин за плодове
Магазин за плодове в **работни дни** продава на следните **цени**:

|Плод      |Цена |
|:--------:|:---:|
|banana    |2.50 |
|apple     |1.20 |
|orange    |0.85 |
|grapefruit|1.45 |
|kiwi      |2.70 |
|pineapple |5.50 |
|grapes    |3.85 |

В почивни дни цените са **по-високи**:

|Плод      |Цена |
|:--------:|:---:|
|banana    |2.70 |
|apple     |1.25 |
|orange    |0.90 |
|grapefruit|1.60 |
|kiwi      |3.00 |
|pineapple |5.60 |
|grapes    |4.20 |

Напишете програма, която **чете** от конзолата **плод** (banana / apple / …),
**ден от седмицата** (Monday / Tuesday / …) и **количество (десетично число)**
и **пресмята цената** според цените от таблиците по-горе.
Резултатът да се отпечата **закръглен с 2 цифри след десетичния знак**.
При **невалиден ден** от седмицата или **невалидно име** на плод да се отпечата
**“error”**.

#### Примерен вход и изход
|Вход                 |Изход|Вход                 |Изход|
|---------------------|-----|---------------------|-----|
|orange<br>Sunday<br>3|2.70 |kiwi<br>Monday<br>2.5|6.75 |

|Вход                     |Изход|Вход                   |Изход|
|-------------------------|-----|-----------------------|-----|
|grapes<br>Saturday<br>0.5|2.10 |tomato<br>Monday<br>0.5|error|

<!--
TODO: обясни / направи форматирането до 2 знака
TODO: picture
-->

#### Решение
![](/assets/old-images/chapter-4-images/07.Fruit-shop-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#6>.

### Пример: търговски комисионни
Фирма дава следните **комисионни** на търговците си според **града**, в който
работят и **обема на продажбите s**:

|Град   |0 <= s <= 500 |500 < s <= 1000 |1000 < s <= 10000 |s > 10000 |
|:-----:|:------------:|:--------------:|:----------------:|:--------:|
|Sofia  |5%            |7%              |8%                |12%       |
|Varna  |4.5%          |7.5%            |10%               |13%       |
|Plovdiv|5.5%          |8%              |12%               |14.5%     |

Напишете **програма**, която чете име на **град** (стринг) и обем на
**продажбите** (десетично число) и изчислява размера на комисионната.
Резултатът да се изведе закръглен с **2 десетични цифри след десетичния знак**.
При **невалиден град или обем на продажбите** (отрицателно число) да се отпечата
"**error**".

#### Примерен вход и изход
|Вход         |Изход |Вход             |Изход|Вход            |Изход|
|-------------|------|-----------------|-----|----------------|-----|
|Sofia<br>1500|120.00|Plovdiv<br>499.99|27.50|Kaspichan<br>-50|error|

#### Решение
За да изчислим комисионната според града и обема на продажбите се нуждаем от
няколко вложени **`if` проверки**.

За да разпознаем ако входът е навалиден, първоначално задаваме стойността на
комисионната да е  **`-1`**.
Ако градът и ценовият диапазон бъдат намерени, тя ще бъде променена, а ако има
грешка, ще остане отрицателна.

<!--
TODO: picture
-->
![](/assets/old-images/chapter-4-images/08.Trade-comissions-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#7>.

<table><tr><td><img src="/assets/alert-icon.png" style="max-width:50px" /></td>
<td><b>Добра практика</b> е да използваме <b>блокове</b>, които <b>заграждаме</b> с къдрави скоби <b><code>{ }</code></b> след <b><code>if</code></b> и <b><code>else</code></b>. Също така, препоръчително e при писане да <b>отместваме</b> кода <b>след <code>if</code> и <code>else</code></b> с една табулация <b>навътре</b>, за да направим кода по-лесно четим.</td>
</tr></table>

## Условна конструкция switch-case
Конструкцията **`switch-case`** работи като поредица **`if-else`** блокове.
Когато работата на програмата ни зависи от стойността на **една променлива**,
вместо да правим последователни проверки с **`if-else`** блокове, можем да
**използваме** условната конструкция **`switch`**.
Тя се използва за **избор измежду списък с възможности**.
Конструкцията сравнява дадена стойност с определени константи и в зависимост от
резултата предприема действие.

**Променливата**, която искаме да **сравняваме**, поставяме в **скобите след
оператора `switch`** и се нарича "**селектор**".
Тук **типът трябва да е сравним** (числа, стрингове).
**Последователно** започва **сравняването** с всяка една **стойност**, която
**се намира** след **`case` етикетите**.
При съвпадение започва изпълнението на кода от съответното място и продължава,
докато стигне оператора **`break`**.
В някои програмни езици (като C и C++) **`break`** може да се изпуска, за да се
изпълнява код от друга **`case`** конструкция, докато не стигне до въпросния
оператор.
В C++ обаче, наличието на **`break`** е **задължителен** за **всеки `case`**,
който съдържа изпълнение на програмна логика.
При **липса** на **съвпадение**, се изпълнява **`default`** конструкцията,
**ако** такава **съществува**.

```csharp
switch (селектор)
{
    case стойност1:
        конструкция;
        break;
    case стойност2:
        конструкция;
        break;
    case стойност3:
        конструкция;
        break;
    …
    default:
        конструкция;
        break;
}
```

### Пример: ден от седмицата
Нека напишем програма, която принтира **деня от седмицата** (на английски)
според **въведеното число** (1 … 7) или "**Error!**", ако е подаден невалиден
ден.

#### Примерен вход и изход
|Вход        |Изход                     |
|------------|--------------------------|
|1<br>7<br>-1|Monday<br>Sunday<br>Error!|

#### Решение
![](/assets/old-images/chapter-4-images/09.Day-of-week-01.png)

<table><tr><td><img src="/assets/alert-icon.png" style="max-width:50px" /></td>
<td><b>Добра практика</b> е на <b>първо</b> място да поставяме онези <b><code>case</code> случаи</b>, които обработват <b>най-често случилите се ситуации</b>, а <b><code>case</code> конструкциите</b>, обработващи <b>по-рядко възникващи ситуации</b>, да оставим в <b>края преди <code>default</code> конструкцията</b>. Друга <b>добра практика</b> е да <b>подреждаме <code>case</code> етикетите</b> в <b>нарастващ ред</b>, без значение дали са целочислени или символни.</td>
</tr></table>

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#8>.

### Множество етикети в switch-case
В **C++** имаме възможността да **използваме множество `case`** етикети,
когато те трябва да изпълняват **един и същи** код.
При този начин на записване, когато **програмата** ни намери **съвпадение**, ще
изпълни **следващия** срещнат код, тъй като **след** съответния **`case`**
етикет **липсва код** за изпълнение и **`break`** оператор.

```csharp
switch (селектор)
{
    case стойност1:
    case стойност2:
    case стойност3:
        конструкция;
        break;
    case стойност4:
    case стойност5:
        конструкция;
        break;
    …
    default:
        конструкция;
        break;
}
```

### Пример: вид животно
Напишете програма, която принтира вида на животно според името му: 
* dog -> **mammal**
* crocodile, tortoise, snake -> **reptile**
* others -> **unknown**

#### Примерен вход и изход
|Вход    |Изход  |Вход|Изход |Вход    |Изход  |
|--------|-------|----|------|--------|-------|
|tortoise|reptile|dog |mammal|elephant|unknown|

#### Решение
Можем да решим задачата чрез **`switch`**-**`case`** проверки с множество
етикети по следния начин:

![](/assets/old-images/chapter-4-images/10.Animal-type-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#9>.

## Какво научихме от тази глава?
Да си припомним новите конструкции и програмни техники, с които се запознахме в
тази глава.

### Вложени проверки
```cpp
if (условие_1) {
    if (условие_2)
        // тяло;
    else
        // тяло;
}
```
### По-сложни проверки с &&, ||, ! и ()
```cpp
if (((x == left) || (x == right)) && (y >= top) && (y <= bottom))
    cout <<...<< endl;
```

#### Switch-case проверки
```csharp
switch (селектор)
{
    case стойност1:
        конструкция;
        break;
    case стойност2:
    case стойност3:
        конструкция;
        break;
    …
    default:
        конструкция;
        break;
}
```


## Упражнения: по-сложни проверки
Нека сега да упражним работата с по-сложни проверки.
Да решим няколко практически задачи.

### Задача: кино
В една кинозала столовете са наредени в **правоъгълна** форма в **r** реда и
**c** колони.
Има три вида прожекции с билети на **различни** цени:

* **Premiere** – премиерна прожекция, на цена **12.00** лева.
* **Normal** – стандартна прожекция, на цена **7.50** лева.
* **Discount** – прожекция за деца, ученици и студенти на намалена цена от
  **5.00** лева.

Напишете програма, която въвежда **тип прожекция** (стринг), брой **редове** и
брой **колони** в залата (цели числа) и изчислява **общите приходи** от билети
при **пълна зала**.
Резултатът да се отпечата във формат като в примерите по-долу - с 2 цифри след
десетичния знак.

#### Примерен вход и изход
|Вход                |Изход       |Вход              |Изход       |
|--------------------|------------|------------------|------------|
|Premiere<br>10<br>12|1440.00 leva|Normal<br>21<br>13|2047.50 leva|

#### Насоки и подсказки
При прочитането на входа можем да обърнем типа на прожекцията в малки букви
(с функцията **`.ToLower()`**).
Създаваме и инициализираме променлива, която ще ни съхранява изчислените
приходи.
В друга променлива пресмятаме пълния капацитет на залата.
Използваме **`switch-case`** условна конструкция, за да изчислим прихода в
зависимост от вида на прожекцията и отпечатваме резултата на конзолата в
зададения формат (потърсете нужната **C++** функционалност в интернет).

Примерен код (части от кода са замъглени с цел да се стимулира самостоятелно
мислене и решение):

![](/assets/old-images/chapter-4-images/11.Cinema-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#10>.

### Задача: волейбол
Влади е студент, живее в София и си ходи от време на време до родния град.
Той е много запален по волейбола, но е зает през работните дни и играе
**волейбол** само през **уикендите** и в **празничните дни**.
Влади играе **в София** всяка **събота**, когато **не е на работа** и **не си
пътува до родния град**, както и в **2/3 от празничните дни**.
Той пътува до **родния си град h пъти** в годината, където играе волейбол със
старите си приятели в **неделя**.
Влади **не е на работа 3/4 от уикендите**, в които е в София.
Отделно, през **високосните години** Влади играе с **15% повече** волейбол от
нормалното.
Приемаме, че годината има точно **48 уикенда**, подходящи за волейбол.
Напишете програма, която изчислява **колко пъти Влади е играл волейбол** през
годината.
**Закръглете резултата** надолу до най-близкото цяло число
(напр. 2.15 -> 2; 9.95 -> 9).

Входните данни се четат от конзолата:
* Първият ред съдържа думата “**leap**” (високосна година) или “**normal**”
  (нормална година с 365 дни).
* Вторият ред съдържа цялото число **p** – брой празници в годината (които не са
  събота или неделя).
* Третият ред съдържа цялото число **h** – брой уикенди, в които Влади си пътува
  до родния град.

#### Примерен вход и изход
|Вход          |Изход|Вход            |Изход|
|--------------|-----|----------------|-----|
|leap<br>5<br>2|45   |normal<br>3<br>2|38   |

|Вход             |Изход|Вход          |Изход|
|-----------------|-----|--------------|-----|
|normal<br>11<br>6|44   |leap<br>0<br>1|41   |

#### Насоки и подсказки
Стандартно прочитаме входните данни от конзолата като за избягване на грешки
при въвеждане обръщаме текста в малки букви с функцията **`.ToLower()`**.
Последователно пресмятаме **уикендите прекарани в София**, **времето за игра в
София** и **общото време за игра**.
Накрая проверяваме дали годината е **високосна**, правим допълнителни изчисления
при необходимост и извеждаме резултата на конзолата **закръглен надолу** до
най-близкото **цяло число** (потърсете **C++** клас с такава функционалност в
интернет).

Примерен код (части от кода са замъглени с цел да се стимулира самостоятелно
мислене и решение):

![](/assets/old-images/chapter-4-images/11.Volleyball-01.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#11>.

### Задача: * точка във фигурата
Фигура се състои от **6 блокчета с размер h \* h**, разположени като на
фигурата.
Долният ляв ъгъл на сградата е на позиция {0, 0}.
Горният десен ъгъл на фигурата е на позиция {**2\*h**, **4\*h**}.
На фигурата координатите са дадени при **h = 2**:

![](/assets/old-images/chapter-4-images/13.Point-in-the-figure-01.png)

Да се напише програма, която въвежда цяло число **h** и координатите на дадена
**точка {x, y}** (цели числа) и отпечатва дали точката е вътре във фигурата
(**inside**), вън от фигурата (**outside**) или на някоя от стените на фигурата
(**border**).

#### Примерен вход и изход
|Вход          |Изход  |Вход          |Изход  |
|--------------|-------|--------------|-------|
|2<br>3<br>10  |outside|2<br>3<br>1   |inside |
|2<br>2<br>2   |border |2<br>6<br>0   |border |
|2<br>0<br>6   |outside|15<br>13<br>55|outside|
|15<br>29<br>37|inside |15<br>37<br>18|outside|
|15<br>-4<br>7 |outside|15<br>30<br>0 |border |

#### Насоки и подсказки
Примерна логика за решаване на задачата (не е единствената правилна):
* Може да разделим фигурата на **два правоъгълника** с обща стена:
<p align="center">
<img src="/assets/old-images/chapter-4-images/13.Point-in-the-figure-03.png" />
</p>
* Една точка е **външна (outside)** за фигурата, когато е едновременно **извън**
  двата правоъгълника.
* Една точка е **вътрешна (inside)** за фигурата, ако е вътре в някой от
  правоъгълниците (изключвайки стените им) или лежи върху общата им стена.
* В **противен случай** точката лежи на стената на правоъгълника (**border**).

Примерен код (части от кода са замъглени с цел да се стимулира самостоятелно
мислене и решение):
![](/assets/old-images/chapter-4-images/13.Point-in-the-figure-02.png)

#### Тестване в Judge системата
Тествайте решението си тук:
<https://judge.softuni.bg/Contests/Practice/Index/508#12>.
